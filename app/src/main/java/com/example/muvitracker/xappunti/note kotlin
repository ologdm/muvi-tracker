// NUOVA REPOSITORY

// koltin notes
//  list.find {condizione} -> restituisce Elemento or null

// livedata
// combineLast (1,2,combiner) -> return crea 3, ogni cambiam 1o2 3 cambierÃ  di nuovo
// concat (1,2) -> return crea live di (1 o 2), viene mostrato il piu recente tra i 2



// IoResponse appunti.....................................................................................
sealed interface IoResponse<out T> {
    data class Success<T>(val dataValue: T) : IoResponse<T>
    data object NetworkError : IoResponse<Nothing> // senza costruttore
    data object OtherError : IoResponse<Nothing>


    companion object {
        fun <T> success(dataValue: T): IoResponse<T> {
            return IoResponse.Success(dataValue)
        }
    }


}


fun <T, R> IoResponse<T>.ioMapper(mapper: (T) -> R): IoResponse<R> {
    return when (this) {
        is IoResponse.Success -> IoResponse.Success(mapper(dataValue)) // ricostruisco il success || (mapper(dataValue) passaggio non chiaro
        is IoResponse.NetworkError -> this
        is IoResponse.OtherError -> this
    }
}


/* // !!!! esempio semplificato
data class Success<T>(val dataValue: T) : IoResponse<T>
data object NetworkError : IoResponse<Nothing> // senza costruttore
data object OtherError : IoResponse<Nothing>
 */


//fun <R> Success<List<BoxoDto>>.ioMapper(mapper: (List<BoxoDto>) -> R): IoResponse<R> {
//    return Success(mapper(dataValue))
//}


// ### notes ###
// data object da v 1.9
// <out T> - out serve altrimenti in enqueue non funzione
